T = int(input())

for time in range(1, T+1):
    # 원소의 개수는 10개
    N = 10

    # 원소의 합이 0인 부분 집합의 개수
    count_0 = 0

    # 10개의 정수
    numbers = list(map(int, input().split()))

    # 원소의 개수가 N개인 집합의 부분 집합의 개수는 2**N == 1<<N
    # 모든 부분 집합을 다 한번씩 만들어 보고 합이 0이 되는지 확인
    # 부분 집합의 개수 만큼 반복 (2**N)
    for i in range(1<<N):
        # i를 부분 집합의 번호(인덱스) 라고 생각하자
        # i를 이진수로 바꿔서 생각

        # 이진수의 각 자리수는 0 또는 1
        # 이진수의 어떤 자릿수에 1이 있는 경우 => 
        # 그 자리(인덱스)에 있는 원소를 부분 집합에 포함
        # 이진수의 어떤 자리수에 0이 있는 경우 =>
        # 그 자리(인덱스)에 있는 원소는 포함하지 않음

        # 어떤 자릿수에 1이 있는지 없는지 어떻게 알아낼 것이냐??
        # 비트 연산자 & 사용 
        # (True and True == True ///// 1 & 1 == 1)

        # 1 1 1 1 0 0 0 0 1 
        #                 &
        #                 1
        # -----------------
        #                 1  => 1과 비교했을 때 결과가 1
        #                    => 1을 왼쪽으로 0번 밀었을 때 1이 있다.
        #                    => 0번 원소는 부분 집합에 포함

        # 1 1 1 1 0 0 0 0 1 
        #               & &
        # 0 0 0 0 0 0 0 1 0
        # -----------------
        #               0 0  => 1 0 과 비교했을 때 결과가 0
        #                    => 1을 왼쪽으로 1번 밀었을 때 1이 없다.
        #                    => 1번 원소는 부분 집합에 미포함
        # .....
        
        # 1 1 1 1 0 0 0 0 1 
        #                 &
        #                 1
        # -----------------
        # 1 0 0 0 0 0 0 0 0 ==> 비교했을 때 결과가 0이 아니다.
        #                   ==> 1을 왼쪽으로 7번 밀었을 때 1이 있다.
        #                   ==> 7번 원소는 부분 집합에 포함

        # i번 째 부분집합의 합
        ith_subset_sum = 0
        ith_subset = []

        # 밀은 횟수 == 시프트한 횟수 == j
        for j in range(N):
            # 이진수 1을 왼쪽으로 최대 N-1 번까지 밀어보면서(쉬프트) 확인
            # j번 비트
            if i & (1<<j):
                # 부분 집합의 인덱스 번호 i를 이진수로 생각하고 
                # 1을 왼쪽으로 j번 쉬프트한 결과와 & 연산
                # 결과가 0이다 => j번 원소는 부분 집합에 미포함
                # 결과가 0이 아니다 => j번 원소는 부분 집합에 포함
                # 현재 i번 부분 집합에는 numbers[j] => 
                # 부분 집합에 포함이 되어있다.
                ith_subset_sum += numbers[j]
                ith_subset.append(numbers[j])

        # 모든 비트를 다 검사하고 나면 부분 집합이 완성
        if ith_subset_sum == 0:
            print(ith_subset)
            # 부분 집합의 합이 0이 되는 경우의 수
            count_0 += 1
            
    print(f"#{time} {count_0}")