# 01_make_numbers.py

## 문제점: 중복된 순열 탐색
01_make_numbers.py 코드는 operators 리스트(예: ['+', '+', '-', '/'])에 포함된 연산자들의 모든 순열을 생성하고 있습니다. 하지만 이 리스트에는 +처럼 동일한 연산자가 여러 개 포함될 수 있어, 같은 연산 순서를 중복으로 탐색하는 비효율이 발생합니다.

- 예시: 연산자 카드가 ['+', '+', '-']일 경우

    - 첫 번째 +를 op1, 두 번째 +를 op2라고 가정해 보겠습니다.

    - 현재 알고리즘은 (op1, op2, -) 순서와 (op2, op1, -) 순서를 서로 다른 경우로 취급하여 각각 끝까지 탐색합니다.

    - 하지만 두 경우 모두 최종 연산자 순서는 (+, +, -)로 동일하며, 계산 결과도 같습니다.

N이 커지고 중복된 연산자가 많아질수록, 이렇게 겹치는 순열을 계산하는 횟수는 기하급수적으로 늘어나 시간 초과의 원인이 됩니다.

## 해결책: 더 효율적인 DFS (계산 과정을 재귀에 통합)
연산자 순열을 미리 만들지 않고, 재귀적으로 계산을 진행하면서 각 단계마다 사용 가능한 연산자 카드를 하나씩 소모하는 방식으로 중복을 제거할 수 있습니다.

새로운 재귀 함수 solve(index, current_value)
- index: 다음에 계산에 사용될 숫자의 인덱스

- current_value: index-1번째 숫자까지 계산된 중간 결과값

알고리즘 흐름
1. 시작: solve(1, numbers[0])으로 첫 호출을 시작합니다.

- index는 1 (두 번째 숫자)

- current_value는 numbers[0] (첫 번째 숫자)

2. 재귀: solve 함수는 아직 사용할 수 있는 연산자 카드가 남아있다면 하나씩 적용해 봅니다.

    - 만약 + 카드가 남아있다면:

        1. \+ 카드 개수를 1 감소시킵니다.

        2. solve(index + 1, current_value + numbers[index])를 재귀 호출합니다.

        3. 호출이 끝나면, 백트래킹을 위해 + 카드 개수를 다시 1 증가시켜 원상 복구합니다.

    - -, *, / 연산자에 대해서도 동일한 과정을 반복합니다.

3. 종료: index가 N이 되면 모든 숫자를 사용한 것이므로, current_value를 이용해 최대/최소값을 갱신합니다.

이 방식은 연산자의 종류별 개수만 추적하므로, 똑같은 연산자 순서에 대해 중복 계산을 하지 않아 훨씬 효율적입니다.

# 02_screen_protector.py
